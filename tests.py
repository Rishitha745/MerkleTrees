import subprocess
import csv
import time
import os
from datetime import datetime

# -------------------------------------------------------------
# CONFIGURATIONS TO TEST
# -------------------------------------------------------------

DEPTHS       = [12, 16, 20, 24]
THREADS      = [2, 4, 8, 16, 32, 64]
BATCH_SIZES  = [1024, 2048, 4096]
TOTAL_OPS    = [50000, 100000, 500000, 1000000]

BINARY = "./bench.out"
SUMMARY_FILE = "all_results.csv"


# -------------------------------------------------------------
# Helper: Run one benchmark configuration
# -------------------------------------------------------------
def run_one(depth, batch, threads, ops):
    print(f"\n================================================================")
    print(f"Running configuration: DEPTH={depth}  BATCH={batch}  THREADS={threads}  OPS={ops}")
    print("================================================================\n")

    # Prepare input for the C++ binary
    input_data = f"{depth}\n{batch}\n{threads}\n{ops}\n"

    # Run bench.out and capture stdout/stderr
    result = subprocess.run(
        [BINARY],
        input=input_data.encode(),
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )

    # Decode outputs
    output = result.stdout.decode(errors="ignore")
    error  = result.stderr.decode(errors="ignore")

    # Print full program output
    print("----- BENCH.OUT OUTPUT BEGIN -----")
    print(output)
    print("----- BENCH.OUT OUTPUT END -------\n")

    if error.strip():
        print("----- BENCH.OUT STDERR -----")
        print(error)
        print("-----------------------------\n")

    # Summary file should be produced by benchmark
    if not os.path.exists("summary_metrics.csv"):
        print("ERROR: Missing summary_metrics.csv for this configuration!")
        return None

    # Read the single-row summary generated by the benchmark
    with open("summary_metrics.csv", "r") as f:
        rows = list(csv.DictReader(f))

    if len(rows) == 0:
        print("ERROR: summary_metrics.csv is empty!")
        return None

    summary = rows[0]

    # Add configuration parameters explicitly (safety)
    summary["depth"] = depth
    summary["batchSize"] = batch
    summary["numThreads"] = threads
    summary["totalOps"] = ops

    return summary


# -------------------------------------------------------------
# MAIN LOOP — Run all combinations and store their results
# -------------------------------------------------------------
all_results = []
combinations = len(DEPTHS) * len(BATCH_SIZES) * len(THREADS) * len(TOTAL_OPS)
count = 0

print(f"\nRunning TOTAL {combinations} configurations...\n")

for d in DEPTHS:
    for b in BATCH_SIZES:
        for t in THREADS:
            for o in TOTAL_OPS:
                count += 1
                print(f"### [{count}/{combinations}] Starting test ###")

                row = run_one(d, b, t, o)
                if row:
                    all_results.append(row)

                print(f"### Completed {count}/{combinations} ###\n")
                time.sleep(0.1)


print("========================================")
print(f"BENCHMARKING COMPLETE: {len(all_results)} results collected")
print("========================================\n")


# -------------------------------------------------------------
# WRITE MASTER CSV WITH ALL RESULTS
# -------------------------------------------------------------
if all_results:
    keys = all_results[0].keys()

    with open(SUMMARY_FILE, "w", newline="") as f:
        writer = csv.DictWriter(f, fieldnames=keys)
        writer.writeheader()
        writer.writerows(all_results)

    print(f"Final combined CSV written to: {SUMMARY_FILE}")
else:
    print("No results collected — something went wrong.")

print("\nDone!")
